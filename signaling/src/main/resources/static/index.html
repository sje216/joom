<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>WebRTC Signaling Test</title>
</head>
<body>
<h2>WebRTC Signaling Test</h2>

<label>Room ID</label>
<input id="roomId" value="room1"><br><br>

<label>User ID</label>
<input id="userId" value="user1"><br><br>

<button onclick="join()">Join Room</button>

<pre id="log"></pre>

<video id="localvideo" autoplay playsinline muted width="300"></video>
<video id="remotevideo" autoplay playsinline muted width="300"></video>

<script>
    //let ws, pc, localStream, myRole;
    let ws, localStream, myRole;
    let pcs = {};
    let pendingCandidates = [];

    // rtcpeerconnection ìƒì„±
    const config = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' }
        ]
    }

    function log(msg) {
      document.getElementById("log").textContent += msg + "\n";
    }

    window.onload = function () {
        ws = new WebSocket("ws://localhost:8080/ws");

          ws.onopen = () => log("âœ… WebSocket connected");
          ws.onmessage   = async (e) => {
            const msg    = JSON.parse(e.data);
            switch (msg.type) {
                case "JOIN_ACK":

                    myRole = msg.role;
                    log("ðŸŽ­ role = " + myRole);
                    await startCam();
                    break;

                case "PEER_READY":
                    log("ðŸ‘¥ peer ready");
                    if(myRole === "CALLER"){
                        await sendOffer();
                    }
                    break;

                case "LEAVE":
                    log("ðŸ‘¤ leaved: " + msg.userId);
                    break;

                case "OFFER":
                  log("ðŸ“© OFFER received from " + msg.userId);
                  await pc.setRemoteDescription(msg.sdp);
                  for(const c of pendingCandidates){
                    await pc.addIceCandidate(c);
                  }

                  pendingCandidates = [];

                  const answer = await pc.createAnswer();
                  await pc.setLocalDescription(answer);
                  ws.send(JSON.stringify({
                    type: "ANSWER",
                    roomId: roomId.value,
                    userId: userId.value,
                    target: msg.userId,
                    sdp: answer
                  }));
                  break;

                case "ANSWER":
                  log("ðŸ“© ANSWER received");
                  await pc.setRemoteDescription(msg.sdp);
                  break;

                case "ICE":
                  log("ICE received from " + JSON.stringify(msg.candidate));
                  if(pc.remoteDescription){
                    await pc.addIceCandidate(msg.candidate);
                  } else {
                    pendingCandidates.push(msg.candidate);
                  }
                  break;
            }
        };
          ws.onerror = (e) => log("âŒ error");
          ws.onclose = () => log("ðŸ”Œ closed");
    }

    function join() {
      ws.send(JSON.stringify({
        type: "JOIN",
        roomId: roomId.value,
        userId: userId.value
      }));

    }

    async function startCam() {
        // ì¹´ë©”ë¼ëž‘ ë§ˆì´í¬ ì¼œê¸°
        localStream = await navigator.mediaDevices.getUserMedia({
         video: true,
         audio: true
          });

        // ë‚´ í™”ë©´ì— ë‚´ ì˜ìƒ ë³´ì—¬ì¤Œ
        document.querySelector("#localvideo").srcObject = localStream;

        // webRTC ì „í™”ê¸° ë§Œë“¦
        pc = new RTCPeerConnection(config);


        // ë‚´ ì˜ìƒ ìŒì„±ì„ ì „í™”ê¸°ì— ê½‚ê¸°
        localStream.getTracks().forEach(track => {
        pc.addTrack(track, localStream);
        });

        // ìƒëŒ€ ì˜ìƒì´ ë“¤ì–´ì˜¤ë©´ í™”ë©´ì— ì¶œë ¥
        pc.ontrack = e => {
            //log("ontrack event = " + e.streams[0].getTracks().map(t => t.kind).join(","));
            remotevideo.srcObject = e.streams[0];
        }

        // iceí›„ë³´ê°€ ìƒê¸¸ë•Œ ë§ˆë‹¤ ì„œë²„ë¡œ ì „ì†¡
        pc.onicecandidate = e => {
            if(e.candidate) {
                log("ðŸ§Š ICE generated: " + JSON.stringify(e.candidate));
                ws.send(JSON.stringify({
                    type: "ICE",
                    roomId: roomId.value,
                    userId: userId.value,
                    target: userId.value === "user1" ? "user2" : "user1",
                    candidate: e.candidate, // ì—°ê²° ì£¼ì†Œ ì •ë³´
                }));
            }
        };
    }

    //
    async function sendOffer() {
        log("ðŸ“¤ sendOffer() called");
        // í†µí™” ì œì•ˆì„œ ë§Œë“¤ê¸°
        const offer = await pc.createOffer();
        // ì´ê±° ë‚´ê°€ ë³´ë‚¼ ì •ë³´ì•¼ ë¼ê³  ì „í™”ê¸°ì— ì €ìž¥
        await pc.setLocalDescription(offer);
        // ì‹œê·¸ë„ë§ ì„œë²„ì—ê²Œ ì´ offer user2 ì—ê²Œ ì „ë‹¬
        ws.send(JSON.stringify({
            type: "OFFER",
            roomId: roomId.value,
            userId: userId.value,
            target: userId.value === "user1" ? "user2" : "user1",
            sdp: offer
        }));
    }


    function createPC(peerId){
        const pc = new RTCPeerConnection(config);

        localStream.getTracks().forEach(track => {
            pc.addTrack(track, localStream);
        };

        pc.ontrack = e => {
            remotevideo.srcObject = e.streams[0];
        }

        pc.onicecandidate = e => {
            if(e.candidate) {
                ws.send(JSON.stringify({
                    type: "ICE",
                    target: peerId,
                    candidate: e.candidate,
                }));
            }
        }

        pcs[peerId] = pc;
        return pc;
    }

</script>
</body>
</html>